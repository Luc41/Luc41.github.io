{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/07/hello-world/"},{"title":"Go语言入门","text":"最近开始搭建个人网站，在后端技术栈的选择上犹豫了很久。综合了网络上的各种评价最终选择了golang。作为一个新近开源的语言，go语言较为简单，符合我的需求同时具有完善的框架。 概述Go语言被设计成一门应用于搭载在Web服务器，存储集群，或其他类似用途的服务器系统编程语言。Go相对于其他大多数语言有着更高的开发效率。 Go语言于2009年开源，未来前景相当不错。 官方网站 官方中文文档 基础Go语言的基础内容和语法 包（package）每个Go程序都是由包构成。按照约定，包名与导入路径的最后一个元素一致，例：math/rand 中的源码均以package rand 语句开始。 示例1：package.go 12345678910package mainimport ( \"fmt\" \"math/rand\")func main() { fmt.Println(\"我最爱的数字是\",rand.Intn(10))} 运行结果1： 首先要把源码编译成二进制文件，直接在shell里面输入命令 1$ go build package.go 运行编译完成的二进制文件 1$ .\\packages.exe 可以看到shell输出了结果 1我最爱的数字是 1 包的导入和导出（import &amp; export）示例1展示了包的“分组”导入形式，即 1234import ( \"fmt\" \"math/rand\") Go也同时支持多个导入语句 12import \"fmt\"import \"math/rand\" 包的导出名均以大写字母开头，例如：math.Pi，在包外只能使用已导出的名字，任何“未导出”的名字在该包外均无法访问，例如math.pi编译后运行便会报错 示例2：exported.go 12345678910package mainimport ( \"fmt\" \"math\")func main() { fmt.Println(math.pi)} 编译运行 12$ go build .\\exported.go$ .\\exported.exe 输出 12.\\exported-names.go:9:14:cannot refer to unexported name math.pi.\\exported-names.go:9:14:undefined:math.pi 改为math.Pi后报错消失 函数（funtion）函数的定义格式如下： 123func function_name( [parameter list] ) [return types] { function body} func ：函数开始声明 function_name：函数的名称，函数名和参数列表一起构成函数签名 parameter list：参数列表，每个参数需要声明其名称和类型，类型在变量名之后。函数可以没有参数或者接受多个参数，多个参数用逗号进行分隔，多个形参类型相同时可以采用省略写法，例如： 1x int , y int 与 1x , y int 的效果是相同的 return_types：返回类型，函数返回值的数据类型，与参数相同，函数也可以返回任意数量的返回值，不需要返回值的情况下return_typs不是必须的 function body：函数体，没啥好说的，函数定义的代码段 示例3：function.go 1234567891011package mainimport \"fmt\"func add(x,y int) int { return x+y}func main() { fmt.Println(add(42,13))} 编译运行 12$ go build .\\function.go$ .\\function.exe 输出55 函数的返回值可以被命名，其名称应具有一定的意义，并可以作为文档使用，例如 12345func split(sum int) (x,y int) { x=sum*4/9 y=sum-x return} 没有参数的return语句会返回已命名的返回值，即直接返回，直接返回在长的函数中会影响其可读性 变量（variables）变量的定义格式如下 1var [ variable_name ] [ variable_type ] = [ variable_value ] var：变量的声明开始； variable_name：变量的名称； variable_type：变量的数据类型； variable_value：变量声明的初始值，如果初始化值已存在，则可以省略类型； 变量还可以用简洁赋值语句:=声明并赋值，例如 1x := 3 这种方式只能在函数内使用，函数外的每个语句都必须以关键字开始 没有明确初始值的变量声明会被赋值零值，不同类型的零值分别为: 数值类型为0； 布尔类型为false； 字符串为&quot;&quot;（空串）； Go的基本数据类型如下 123456789101112131415bool // 布尔值string // 字符串int int8 int16 int32 int64 // 整型uint uint8 uint16 uint32 uint64 // 无符号整型byte // uint8的别名rune // int32的别名 // 表示一个unicode码点float32 float64 // 浮点型complex64 complex128 // 复数型 通过表达式T(v)可以将变量进行类型转换，例如 123var i int = 42var f float64 = float64(i) //将整型变量i转换为浮点型变量fvar u uint = uint(f) //将浮点型变量f转换为无符号整型变量u 或者还可以写成更加简洁的形式 123i := 42f := float64(i)u := uint(f) 注意Go在不同类型之间赋值需要显式转换 常量常量与变量的声明方法类似，只不过使用const关键字，常量可以是字符、字符串、布尔值或数值 123const pi = 3.14 // 声明一个数值常量const world = \"世界\" // 声明一个字符串常量const truth = true // 声明一个布尔值常量 注意： 常量不能使用:=语法声明 未指定类型的常量由其上下文决定 总结本篇文章大致梳理了Go语言的一些基本语法，总体来讲Go的语法还是比较简洁易懂，基本上还是很好理解的。","link":"/2020/03/13/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"},{"title":"Go语言的控制语句基础","text":"概述控制语句很好理解，即循环、条件等控制代码执行流程的语句，这些语句在Go中的形式与其他语言的差别也很小 循环语句Go只有for循环一种循环语句 一个基本的for语句由三部分组成，每部分用分号隔开 初始化：在第一次迭代前执行 条件表达式： 在每次迭代前进行判断，一旦布尔值为false，循环就会终止 后置语句：在每次迭代的结尾执行 初始化语句通常为一个短变量声明，该声明仅在for语句的作用域中可见 示例1：for.go 1234567891011package mainimport \"fmt\"func main() { sum := 0 for i := 0; i &lt; 10; i++ { sum += i } fmt.Println(sum)} 与其他语言像C、Java等语言不同的是，Go的for语句后面三个部分外没有(),但{}是必需的 示例1编译运行后可以看到程序输出结果 145 for循环的三个部分中初始化语句和后置语句是可选项，例如 123456sum := 1for ; sum &lt; 1000; { sum += sum} // 这个for循环只有一个条件表达式// 初始化语句和后置语句都被省略了 编译运行后输出结果1024,可以看出每次循环都执行sum += sum直到sum的值大于等于1000 在这种情况下把语句中的分号去掉，很容易看出来这就是其他语言中的while循环 12345sum := 1for sum &lt; 1000 { sum += sum} // 在Go中for即是while 至此我们已经省略了for循环三部分中的两部分，如果将剩下的一个部分————条件表达式也省略，这是这个循环就成了无限循环 123for {} // 这是个无限循环 条件语句条件语句包括if、switch等对条件进行判断的语句 if语句与for类似，if语句无需()而{}是必须的,基本形式的的if语句只有一个部分————条件表达式 示例2：if.go 12345678910111213141516171819202122package mainimport ( \"fmt\" \"math\")// 导入fmt和math包func sqrt(x float64) string { if x &lt; 0 { return sqrt(-x) + \"i\" } return fmt.Sprint(math.Sqrt(x))} // 判断x &lt; 0// true 返回-x的计算结果，并在结尾加上表示复数虚部的符号i// false 返回x的计算结果func main() { fmt.Println(sqrt(2),sqrt(-4))} // 输出2和-4的平方根 编译运行后输出结果 11.4142135623730951 2i if语句允许在条件表达式前执行一个简单的语句，该语句声明的变量作用域仅在if之内 示例3：if-with-a-short-statement.go 123456789101112131415161718192021222324package mainimport ( \"fmt\" \"math\")func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v &lt; lim { return v } return lim}// 在条件判断前先声明一个变量v，v的值为x的n次方// 判断v &lt; lim// true 返回v// false 返回limfunc main() { fmt.Println( pow(3, 2, 10), pow(3, 3, 20), )} 编译运行后输出结果 19 20 在if语句后可以选择使用else语句，if语句中的声明在else语句中同样可以使用 对示例3中pow函数稍作修改 12345678910111213func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v &lt; lim { return v } else { fmt.Printf(\"%g &gt;= %g\\n\", v, lim) } // 这里开始就不能使用 v 了 return lim}// 在条件判断前先声明一个变量v，v的值为x的n次方// 判断v &lt; lim// true 返回v// false 返回字符串“ v &gt;= lim ”和lim 编译运行 1227 &gt;= 209 20 注意 实际在main的fmt.Println调用之前对pow函数调用就已经执行完成并返回各自的结果 一个小小的练习练习1：用牛顿法实现平方根函数 12345678910111213141516171819// 迭代10次，计算x的平方根,并打印每次的z值package mainimport ( \"fmt\")func Sqrt(x float64) float64 { z := float64(1) for i:=0 ; i &lt; 10 ; i++ { z -= (z*z - x) / (2*z) fmt.Println(i,\": \",z,\"\\n\") } return z}func main() { fmt.Println(Sqrt(2))} 编译运行 1234567891011121314151617181920210 : 1.5 1 : 1.4166666666666667 2 : 1.4142156862745099 3 : 1.4142135623746899 4 : 1.4142135623730951 5 : 1.414213562373095 6 : 1.4142135623730951 7 : 1.414213562373095 8 : 1.4142135623730951 9 : 1.414213562373095 1.414213562373095 换一种实现方法，当z的值停止改变时退出循环 123456789101112131415161718192021222324package mainimport ( \"fmt\")func Sqrt(x float64) float64 { z := float64(1) i := 0.0 for j := 0; j &gt;= 0; j++ { if i != z { i = z z -= (z*z - x) / (2*z) } else { return z } fmt.Println(j,\":\",z,\"\\n\") } return z}func main() { fmt.Println(Sqrt(2))} 什么是牛顿法： z² − x 是 z² 到它所要到达的值（即 x）的距离， 除以的 2z 为 z² 的导数，我们通过 z² 的变化速度来改变 z 的调整量。 这种通用方法叫做牛顿法。 它对很多函数，特别是平方根而言非常有效。 switch语句switch是编写一连串if-else语句的简便写法，它运行第一个值等于条件表达式的case语句，语法结构如下： 12345678switch var { case val1 : ... case val2 : ... default : ...} 其中var可以是任何类型，val1和val2则是同类型的任意值。 case语句从上到下顺序执行，直到匹配成功。默认情况下Go不会运行之后所有的case语句，即自带break语句。如果需要执行后面的case语句，则需要以fallthrough语句结束。 示例4：switch.go 123456789101112131415161718192021package mainimport ( \"fmt\" \"runtime\")func main() { fmt.Print(\"Go runs on \") //判断Go当前所运行在的系统并返回 switch os := runtime.GOOS; os { case \"darwin\": fmt.Println(\"OS X.\") case \"linux\": fmt.Println(\"Linux.\") default: // freebsd, openbsd, // plan9, windows... fmt.Printf(\"%s.\\n\", os) }} 编译运行 1Go runs on windows switch语句允许没有条件表达式，其等价于switch true，这种形式在面对一长串的if-then-else情况下可以写出更清晰的代码 defer语句defer语句的功能是延迟执行，defer语句会将函数推迟到外层函数返回后再执行，推迟调用的函数其参数会立即求值，但是直到外层函数返回前该函数都不会被调用。 示例5：defer.go 123456789package mainimport \"fmt\"func main() { defer fmt.Println(\"world\") fmt.Println(\"hello\")} 编译运行 12helloworld 多个defer语句的调用遵循后进先出，即推迟执行的函数会被压入一个栈中 示例6：defer-more.go 12345678910111213package mainimport \"fmt\"func main() { fmt.Println(\"counting\") for i := 0;i &lt; 10; i++ { defer fmt.Println(i) } fmt.Println(\"done\")} // 降序输出0-9 编译运行 123456789101112countingdone9876543210","link":"/2020/03/17/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E5%9F%BA%E7%A1%80/"},{"title":"Go指针基础","text":"概述指针是一个变量，它的值是另一个变量的地址，通过指针我们可以直接地访问特定地址的内存单元。通过指针我们可以访问并操作内存单元，运用这个特性可以允许我们写出非常高效的程序。 定义指针变量使用*T表示该指针是指向T类型值的指针，例如： 123var p *int// 指针变量p是一个指向int类型变量的指针// 指针的零值为nil 与C不同，Go并不支持指针运算 与指针变量相关的操作符有&amp;和*，这两个操作符分别代表的指针的两个重要含义，即引用和重定向。 操作符&amp;会生成一个指向其操作数的指针 1234i := 42p = &amp;i// p是一个指向i的指针// p的值是i的内存地址 操作符*表示指针指向的底层值 1234// 通过p读取i的值fmt.Println(*p)// 通过p设置i的值*p = 21 示例1：pointers.go 12345678910111213141516package mainimport \"fmt\"func main() { i, j := 42, 2701 p := &amp;i // 指向 i fmt.Println(*p) // 通过指针读取 i 的值 *p = 21 // 通过指针设置 i 的值 fmt.Println(i) // 查看 i 的值 p = &amp;j // 指向 j *p = *p / 37 // 通过指针对 j 进行除法运算 fmt.Println(j) // 查看 j 的值} 编译运行 123422173 同样，如果将fmt.Println()中的参数换成&amp;i、&amp;j再次编译运行则可以看到输出结果为这两个变量所存储的内存地址 123420x40e0200x40e024 总结指针实际上是一个相当底层的概念，通过指针我们的程序可以直接操作硬件，而这通常是汇编语言的工作。 使用指针的一大优势便是更加高效，直接对硬件中存储的数据进行操作无疑是比通过一层抽象进行操作更加节省时间。 指针的存在正是C语言相较其他高级语言更加高效的一个重要原因 当然这也不完全是好处，如果不清楚内存中的数据和它的结构就贸然地、大量地使用指针很大可能会造成严重的错误。 充分理解了指针，也就基本理解了计算机系统在底层硬件的工作方式，对于程序的编写是大有裨益的。","link":"/2020/03/21/Go%E6%8C%87%E9%92%88%E5%9F%BA%E7%A1%80/"},{"title":"Go派生类型基础","text":"结构体概述结构体struct是一个由相同或者不同类型的数据所构成的集合。 集合中的的元素被称为结构体的成员member，不过在Go中经常被称为字段field实际上是同一个概念。 定义结构体使用如下语法来声明 123456type struct_variable_type struct { member def member def ... member def} 结构体是一种自定义数据结构，type语句声明了这个结构体的类型，这个类型是由用户自定义的，同时在结构体的内部我们需要声明这个结构体所拥有的成员的名称和相应的类型 示例1：struct.go 1234567891011package mainimport \"fmt\"type Vertex struct { X int Y int}func main() { fmt.Println(Vertex{1,2})} 编译运行 1{1 2} 如果我们需要访问或操作结构体的成员，这个时候需要使用点号来实现 示例2：struct-field.go 1234567891011121314package mainimport \"fmt\"type Vertex struct { X int Y int}func main() { v := Vertex{1, 2} v.X = 4 // 对结构体v的成员X赋值 fmt.Println(v.X)} 编译运行 14 通过指针同样可以访问结构体的成员，如果我们定义了一个指针p指向结构体，那么我们便可以通过(*p).X的形式来访问相应的成员 不过这种方式过于啰嗦，通常我们可以隐式地引用，即使用p.X的形式就可以 结构体文法创建一个结构体我们只需要直接列出成员的值便可以，使用name:则可以仅列出部分成员，像下面这样 12345678910// 声明一个结构体type Vertex struct { X, Y int}// 初始化一个Vertex类型的结构体v1 = Vertex{1, 2}// 隐式赋值v2 = Vertex{X: 1} // Y: 0被隐式地赋予v3 = Vertex{} // X:0,Y:0均被隐式赋予 与基本变量相同，结构体同样可以使用&amp;来创建一个指向该结构体的指针 12// 初始化一个*Vertex类型的结构体（指针）p = &amp;Vertex{1, 2} 数组概述数组是一个具有相同且唯一类型的一组编号的、长度固定的数据序列，数组的类型可以是任意类型。 定义数组使用[n]T的形式声明，表示这是一个拥有n个T类型的值的数组，就像这样 1var a [10]int // 初始化一个数组a，a拥有10个int类型的数据 数组的长度是它类型的一部分，所以不能改变它的大小 示例3：array.go 1234567891011121314package mainimport \"fmt\"func main() { var a [2]string a[0] = \"Hello\" a[1] = \"World\" fmt.Println(a[0], a[1]) fmt.Println(a) primes := [6]int{2, 3, 5, 7, 11, 13} fmt.Println(primes)} 编译运行 123Hello World[Hello World][2 3 5 7 11 13] 上面的示例实际上还展示了访问数组中特定元素的方法，即通过索引来访问，数组的索引从0开始 切片概述上面提到数组的大小是不能改变的，因此Go语言提供了另外一种能够动态、灵活地使用数组的方式，这就是切片 定义切片使用[]T来声明一个T类型的切片，切片的边界由两个下标：上界和下界来界定，上下界由冒号分隔a[low : high] 切片可以包含任何类型，甚至包括其他的切片即： 12345&gt;s := [ ][ ]int { [ ]int [ ]int [ ]int&gt;} 这里的s是一个2维切片（数组） 这是一个半开区间，它包括第一个元素但不包括最后一个元素，即a[1 : 4]包含索引从1到3的元素 示例4：slices.go 12345678910package mainimport \"fmt\"func main() { primes := [6]int{2, 3, 5, 7, 11, 13} var s []int = primes[1:4] fmt.Println(s)} 可以看到我们首先声明并初始化了一个数组prime，它的长度是6，接下来我们声明并初始化一个切片s，s拥有数组中索引1到3的元素，编译并运行，我们可以看到运行结果正如我们的期待 1[3 5 7] 上面的例子我们可以看到切片正如其名，它就像是从数组中选择一部分切下一样，或者说切片像是对数组的引用。 实际上切片并不存储任何的数据，它是对底层数组的其中一段的描述，如果我们修改切片中的数据，数组中相应的数据也会被修改，并且与这个切片共享一个数组的其他切片也会受到影响，下面这个示例便展示这种影响 示例5：slice-pointers.go 123456789101112131415161718192021package mainimport \"fmt\"func main() { names := [4]string{ \"John\", \"Paul\", \"George\", \"Ringo\", } fmt.Println(names) a := names[0:2] b := names[1:3] fmt.Println(a, b) b[0] = \"XXX\" fmt.Println(a, b) fmt.Println(names)} 我们首先初始化一个数组names，接着初始化两个切片a和b，它们共享同一个数组names，这时我们修改b中的一个元素的值，我们期望观察到对b的修改也影响到了a和数组primes，即a和primes中对应的值也被修改了 那么我们编译并运行 1234[John Paul George Ringo][John Paul] [Paul George][John XXX] [XXX George][John XXX George Ringo] 可以看到正如我们期望的一样 切片的文法切片文法类似于没有长度的数组文法，如下初始化一个数组 1[3]bool{true, true, false} 而像下面这样没有长度的写法则会创建一个和上面相同的数组，然后构建一个引用这个数组的切片 1[]bool{true, true, false} 初始化一个切片我们也可以利用它的默认行为来忽略上忽略上下界，切片下界默认为0，上界则是该切片的长度，对于下面这个数组 1var a [10]int 有以下切片与其等价 1234a[0:10]a[:10]a[0:]a[:] 示例6：slice-bound.go 12345678910111213141516package mainimport \"fmt\"func main() { s := []int{2, 3, 5, 7, 11, 13} s = s[1:4] fmt.Println(s) s = s[:2] fmt.Println(s) s = s[1:] fmt.Println(s)} 编译运行 123[3 5 7][3 5][5] 切片的长度与容量切片的长度就是它所包含的元素的个数，获取一个切片的长度可以使用len(s)表达式 切片的容量是从他的第一个元素开始数，到其底层数组元素末尾的的元素个数，获取一个切片的容量可以使用cap(s)表达式 示例7：slice-len-cap.go 123456789101112131415161718192021222324package mainimport \"fmt\"func main() { s := []int{2, 3, 5, 7, 11, 13} printSlice(s) // 截取切片使其长度为 0 s = s[:0] printSlice(s) // 拓展其长度 s = s[:4] printSlice(s) // 舍弃前两个值 s = s[2:] printSlice(s)}func printSlice(s []int) { fmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s)} 示例7演示了如何重新切片来扩展切片的长度 编译并运行 1234len=6 cap=6 [2 3 5 7 11 13]len=0 cap=6 []len=4 cap=6 [2 3 5 7]len=2 cap=4 [5 7] 切片的零值是nil 一个nil切片的长度和容量都是0，而且nil切片没有底层数组 通过make创建切片创建一个切片也可以Go语言的内建函数make，它会分配一个元素值为0的数组并返回一个引用该数组的切片 12// 创建一个长度为5的切片a := make([]int, 5) 传入make函数的两个参数分别为切片类型和长度，在上面的例子中切片类型为[]int,切片长度为5，如果想要指定创建的切片的容量则需要传入第三个参数 12// 创建一个长度为0，容量为5的切片b := make([]int , 0, 5) 未指定容量的情况下创建的切片容量等于其长度示例8：making-slices.go 12345678910111213141516171819202122package mainimport \"fmt\"func main() { a := make([]int, 5) printSlice(\"a\", a) b := make([]int, 0, 5) printSlice(\"b\", b) c := b[:2] printSlice(\"c\", c) d := c[2:5] printSlice(\"d\", d)}func printSlice(s string, x []int) { fmt.Printf(\"%s len=%d cap=%d %v\\n\", s, len(x), cap(x), x)} 编译运行 1234a len=5 cap=5 [0 0 0 0 0]b len=0 cap=5 []c len=2 cap=5 [0 0]d len=3 cap=3 [0 0 0] 可以看出在没有指定容量的情况下make函数创建的切片a的容量等于其长度，均为5 向切片内追加元素有些时候我们需要向一个切片内加入新的数据，这种情况我们需要使用append函数 1func append(s []T,vs ...T) []T 其中第一个参数s是一个元素类型为T的切片，其余的类型为T的参数的之会追加到这个切片的末尾示例9：append.go 123456789101112131415161718192021222324package mainimport \"fmt\"func main() { var s []int printSlice(s) // 添加一个空切片 s = append(s, 0) printSlice(s) // 这个切片会按需增长 s = append(s, 1) printSlice(s) // 可以一次性添加多个元素 s = append(s, 2, 3, 4) printSlice(s)}func printSlice(s []int) { fmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s)} 编译运行 1234len=0 cap=0 []len=1 cap=2 [0]len=2 cap=2 [0 1]len=5 cap=8 [0 1 2 3 4] 可以看到append的结果是一个包含原切片所有元素加上新添加元素的切片，而且当这个切片的底层数组过小时，Go会自动分配一个更大的数组，返回的切片也会指向这个新的数组。 切片的遍历使用for循环的range形式可以对一个切片中的所有元素进行遍历 123for i,v := range s { ...} 使用range会使每次迭代返回两个值，第一个值是当前元素的索引，第二个值是该索引对应的元素的一份副本 对应在上面的例子中i是切片s的索引，而v是i对应的元素的值 我们也可以通过赋予_来忽略索引或值 12345678// 忽略值for i,_ := range s { ...}// 忽略索引for _,v := range s { ...} 若只需要索引，则可以直接省略第二个变量 123for i := range s { ...} 示例10：range.go 1234567891011package mainimport \"fmt\"var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}func main() { for i, v := range pow { fmt.Printf(\"2**%d = %d\\n\", i, v) }} 编译运行 123456782**0 = 12**1 = 22**2 = 42**3 = 82**4 = 162**5 = 322**6 = 642**7 = 128 练习实现Pic函数，它返回一个长度为dy的切片，其中每个元素是一个长度为dx,类型为uint8的切片 程序运行时，它会将每个整数解释为灰度值，并显示它所对应的图像 图像可以在一下几个函数中选择： (x+y)/2 x*y x^y x*log(y) x%(y+1) 提示： 需要使用循环来分配[ ][ ]uint8中的每个[ ]uint8; 请使用uint8(intValue)在类型之间转换; 可能会用到math包中的函数; 练习1：exercise-slices.go 123456789101112131415161718192021package mainimport \"golang.org/x/tour/pic\"import \"math\"func Pic(dx, dy int) [][]uint8 { pic_col := make([][]uint8, dy) for i := range pic_col { pic_row := make([]uint8, dx) for j := range pic_row { gray := i*math.Log(float64(j)) pic_row[j] = uint8(gray) } pic_col[i] = pic_row } return pic_col}func main() { pic.Show(Pic)} 编译并运行后显示如下图像 更换一下函数再试试 (x+y)/2: x*y: x^y: x%(y+1) 总结切片基于数组构建，但是相比于数组切片的使用则灵活得多。正是由于这种灵活性，在实际的使用中，切片的使用也常常要比数组广泛得多 作为数组的抽象，实际上切片是动态数组的一种实现 映射概述映射是一个集合，它会将key映射到value，可以通过key来快速检索数据，类似于索引 定义映射使用map语句声明 1var m map[T]v 或者使用make函数 1m :=make(map[T]v) 声明一个T类型映射并初始化，上述两种形式是等价的 映射的零值为nil nil映射没有key，也无法添加key 示例11：maps.go 1234567891011121314151617181920package mainimport \"fmt\"type Vertex struct { Lat, Long float64}var m = map[string]Vertex{ \"Bell Labs\": Vertex{ 40.68433, -74.39967, }, \"Google\": Vertex{ 37.42202, -122.08408, },}func main() { fmt.Println(m)} 编译运行 1map[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}] 我们可以对映射进行多种操作，包括： 插入&amp;修改元素 123456m[key] = elem``` 2. 删除元素``` codedelete(m, key) 检测某个键是否存在 1elem, ok = m[key] 如果该key在映射m中，则ok为true，反之则为false，如果该key不在映射中，则elem是该映射元素类型的零值。 练习实现函数WordCount，它应当返回一个映射，其中包含字符串中每个单词的个数。wc.Test函数则会对此函数执行测试并输出成功还是失败。 strings.Fields会很有帮助 练习2：exercise-maps.go 12345678910111213141516171819package mainimport ( \"golang.org/x/tour/wc\" \"strings\")func WordCount(s string) map[string]int { v := strings.Fields(s) m := make(map[string]int) for i := range v { m[v[i]] += 1 } return m}func main() { wc.Test(WordCount)} 编译运行 123456789101112PASS f(\"I am learning Go!\") = map[string]int{\"Go!\":1, \"I\":1, \"am\":1, \"learning\":1}PASS f(\"The quick brown fox jumped over the lazy dog.\") = map[string]int{\"The\":1, \"brown\":1, \"dog.\":1, \"fox\":1, \"jumped\":1, \"lazy\":1, \"over\":1, \"quick\":1, \"the\":1}PASS f(\"I ate a donut. Then I ate another donut.\") = map[string]int{\"I\":2, \"Then\":1, \"a\":1, \"another\":1, \"ate\":2, \"donut.\":2}PASS f(\"A man a plan a canal panama.\") = map[string]int{\"A\":1, \"a\":2, \"canal\":1, \"man\":1, \"panama.\":1, \"plan\":1} 函数函数值函数同样也是值，它可以像其他值一样被传递，也可以用作函数的参数或者返回值 示例12：function-values.go 1234567891011121314151617181920package mainimport ( \"fmt\" \"math\")func compute(fn func(float64, float64) float64) float64 { return fn(3, 4)}func main() { hypot := func(x, y float64) float64 { return math.Sqrt(x*x + y*y) } fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow))} 编译运行 12313581 第一个输出值为函数hypot(5,12)的返回值,返回值为(55+1212)的平方根； 第二个输出值为函数compute(hypot)的返回值，其中传递给compute的参数hypot是一个函数,返回值为hypot(3,4)，这是一个函数，继续返回则得到最终结果(33+44)的平方根； 第三个输出值的形式与第二个类似，最终输出3^4; 函数的闭包Go函数可以是一个闭包。 闭包是一个函数值，它引用了函数体之外的变量，并且该函数可以访问并赋予引用变量的值。 闭包可以理解为“定义在一个函数内部的函数” 示例13：closures.go 123456789101112131415161718192021package mainimport \"fmt\"func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum }}func main() { pos, neg := adder(), adder() for i := 0; i &lt; 10; i++ { fmt.Println( pos(i), neg(-2*i), ) }} 编译运行 1234567891 -23 -66 -1210 -2015 -3021 -4228 -5636 -7245 -90 在上面的示例中adder函数便返回了一个闭包，每个闭包与各自的sum变量绑定 练习实现函数fibonacci，他返回一个函数（闭包），这个闭包返回一个斐波那契数列。 什么是斐波那契数列 斐波那契数列可以用递归的方法来定义： F_0 = 0 F_1 = 1 F_n = F_n-1 + F_n-2 (n &gt;= 2) 练习3：exercise-fibonacci-closure.go 123456789101112131415161718192021222324252627package mainimport \"fmt\"// 返回一个“返回int的函数”func fibonacci() func() int { num := -1 s := make([]int,10) return func() int { num += 1 if num &lt; 2 { s[num] = num return s[num] } else { s[num] = s[num-1] + s[num-2] return s[num] } return s[num] }}func main() { f := fibonacci() for i := 0; i &lt; 10; i++ { fmt.Println(f()) }} 编译运行 123456789100112358132134","link":"/2020/03/22/Go%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80/"},{"title":"Go语言方法和接口基础","text":"概述几种当前较流行的编程语言在对面向对象编程的设计上都大同小异，Go也不例外，如果理解了面向对象的理念学习起来还是很简单的。 方法概述Go语言中没有其他常见的语言中的类的概念，它通过其他方法来实现面向对象这一设计。 定义方法是一类带特殊接收者参数的函数，这个参数写在func关键字和方法名之间。 我们可以为一个结构体类型定义方法： 示例1：method.go 12345678910111213141516171819package mainimport ( \"fmt\" \"math\")type Vertex struct { X, Y float64}func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y)}func main() { v := Vertex{3, 4} fmt.Println(v.Abs())} 示例中Abs()方法拥有一个Vertex类型的接收者v，或者也可以说Vertex类型的结构体v拥有一个Abs()方法(函数)。 注意 方法即是函数，但他的写法同一般函数不同，下面的这种写法Abs()就只是个正常的函数 123func Abs(v Vertex) float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y)} 两者的差别就在于是否带有接收者参数 上面的例子中，方法的接收者是一个结构体，我们也可以使用其他非结构体类型，它们同样可以声明方法。 不过你只能为在同一个包内定义的类型的接收者声明方法，而不能为其他包内定义的类型的接收者声明方法，也就意味着你不能对Go内建的类型（int、float等）声明方法。（因为这些类型在其他包内定义），下面这个例子我们为一个MyFloat类型的接收者声明了Abs()方法: 示例2：method-continue.go 1234567891011121314151617181920package mainimport ( \"fmt\" \"math\")type MyFloat float64func (f MyFloat) Abs() float64 { if f &lt; 0 { return float64(-f) } return float64(f)}func main() { f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs())} 可以看到我们虽然不能直接对一个float64类型的接收者声明方法，但是实际上Myfloat与float64是等价的，通过type关键字的定义，Myfloat是一种新的类型，但仍然具有float64类型的特性。 指针类型同样可以声明方法，并且不必像示例2中写的那样重新定义一个新的类型，对于一个类型T，在接收者参数中直接使用*T可以为它声明方法。 一个指针接收者的方法可以修改接收者指向的值，这种方法要比使用值接收者更常用 示例3：method-pointers.go 12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"math\")type Vertex struct { X, Y float64}func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y)}func (v *Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f}func main() { v := Vertex{3, 4} v.Scale(10) fmt.Println(v.Abs())} Scale方法的接收者是一个指针，调用这个方法可以修改这个指针所指向的值，也就是我们定义的Vertex类型变量v，我们期望的结果应该是50。 编译运行结果为50，符合我们的期望。 如果将Scale方法的*去掉，则运行结果为5，很明显程序并没有按我们的期望运行。 为什么会出现这种情况？ 将*去掉后Scale方法操作的值不再是变量v本身，而是v的一个副本，我们在main函数一开始声明的v的值并没有受影响。 方法与指针重定向 当以指针为接收者的方法在被调用时，接收者既可以是值也可以是指针： 1234var v Vertexv.Scale(5) // OKp := &amp;vp.Scale(10) // OK 两种形式均可以通过编译 反过来同样成立，在以值为接收者的方法被调用时，接收者同样既可以是值也可以是指针 上面说过使用指针接收者的方法更加常用，这么做的原因有二： 指针接收者的方法能够修改其接收者指向的值 可以避免在每次调用方法是复制该值。在值的类型是大型结构体的时候这么做会更加高效 接口概述接口是一个封装好的代码块所暴露给外部的方法，用户或者其他程序可以通过这个接口调用其中的代码来实现相应的功能而无需关心这段代码的具体形式。 定义在Go中接口是一种类型，是由一个或一组方法签名定义的集合，我们可以初始化一个接口类型的变量，这个变量可以保存任何实现了接口中的方法的值 123456type I interface { M1() int M2() float64 ... Mn() string} 一个类型如果实现了一个接口的所有方法，我们称这歌类型实现了该接口，无需专门显式声明。 示例4：interface.go 123456789101112131415161718192021package mainimport \"fmt\"type I interface { M()}type T struct { S string}// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。func (t T) M() { fmt.Println(t.S)}func main() { var i I = T{\"hello\"} i.M()} 编译运行 1hello 示例中我们在main函数中声明并初始化了一个变量i，它的类型是I，也就是接口类型，它的值为T{“hello”}。 可以看到接口也是值，那么它便同样可以被传递，用作函数的参数或是函数的返回值 示例5：interface-values.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( \"fmt\" \"math\")//声明接口type I interface { M()}//声明类型type T struct { S string}//实现接口（指针）func (t *T) M() { fmt.Println(t.S)}//声明类型type F float64//实现接口（值）func (f F) M() { fmt.Println(f)}func main() { //声明接口值i var i I i = &amp;T{\"Hello\"} describe(i) i.M() i = F(math.Pi) describe(i) i.M()}func describe(i I) { fmt.Printf(\"(%v, %T)\\n\", i, i)} 可以看到describe函数接受一个接口类型的参数，并输出接口值 编译运行 1234(&amp;{Hello}, *main.T)Hello(3.141592653589793, main.F)3.141592653589793 两条结果分别是*T类型接口实现和F类型接口实现，不难看出在内部接口值被看作一个包含值和具体类型的元组。 接口值保存了一个具体的底层类型的具体值 接口值在调用方法时会执行其底层类型的同名方法 多个类型可以实现同名接口，一个接口在面对不同类型的值的时候会执行相应的方法，这也就是面向对象中的多态的概念，即代码可以根据类型采取不同的行为 面对nil值的情况 nil接口值既不保存值也不保存类型，所以对一个nil接口调用方法时编译器会报错，因为这个接口内未包含能够指命该调用哪个具体方法的类型 示例6：nil-inerface-values.go 1234567891011121314151617package mainimport \"fmt\"type I interface { M()}func main() { var i I describe(i) i.M()}func describe(i I) { fmt.Printf(\"(%v,%T)\\n\",i,i)} 编译报错 12(&lt;nil&gt;,&lt;nil&gt;)$panic: runtime error: invalid memory address or nil pointer dereference 可以看到由于接口i的底层类型为nil，编译器无法找到对应的具体方法的类型，所以报出错误：无效的地址或无法解引用nil指针 如果接口的具体值为nil会如何 示例7：interface-values-with-nil.go 1234567891011121314151617181920212223242526272829303132package mainimport \"fmt\"type I interface { M()}type T struct { S string}func (t *T) M() { if t == nil { fmt.Println(\"&lt;nil&gt;\") return } fmt.Println(t.S)}func main() { var i I var t *T i = t describe(i) i.M()}func describe(i I) { fmt.Printf(\"(%v, %T)\\n\", i, i)} 这次接口i指向了一个底层值t，t是一个指针，值为nil，再次编译 12(&lt;nil&gt;,*main.T)&lt;nil&gt; 注意 保存了nil具体值的接口其自身并不为nil 定义了零个方法的接口被称为空接口，空接口可以保存任何类型的值（因为任何类型都至少实现了零个方法） 1var i interface {} 通常我们使用空接口来处理未知类型的值 Go语言提供了访问接口值底层具体值的方式，使用 1t := i.(T) 对一个接口值进行类型断言，该语句断言接口值i保存了具体类型T，并将其底层类型为T的值赋值给t 判断一个接口值是否保存了一个特性类型可以使用 1t,ok := i.(T) 这时类型断言会返回两个值：一个底层值和一个报告断言是否成功的布尔值，如果i保存了一个T，则t为其底层值，ok为true，反之则为t的值为T类型的零值，ok为false。 如果i并没有保存T类型的值，直接使用第一种语句会触发一个恐慌，而使用第二种则不会 示例8：type-assertions.go 12345678910111213141516171819package mainimport \"fmt\"func main() { var i interface{} = \"hello\" s := i.(string) fmt.Println(s) s, ok := i.(string) fmt.Println(s, ok) f, ok := i.(float64) fmt.Println(f, ok) f = i.(float64) // 报错(panic) fmt.Println(f)} 编译运行，我们可以看到编译器因为接口保存的类型与断言类型不符而触发了panic： 1234hellohello true0 false$panic: interface conversion: interface {} is string, not float64 当需要多个类型断言时，我们可以使用类型选择，这是一种按顺序从几个类型断言中选择分支的结构，类型选择的形式与switch语句类似 12345678switch v := i.(type) { case T: //v的类型为T时 ... case S: //v的类型为S时 ... default: // 没有匹配，v的类型与i的类型相同 ...} 类型选择语句可以针对给定接口值所存储的值的类型进行比较，选择符合的类型 类型选择中的声明与类型断言中的i.(T)的语法相同，只不过把T替换成了关键字type 示例9：type-switch.go 1234567891011121314151617181920package mainimport \"fmt\"func do(i interface{}) { switch v := i.(type) { case int: fmt.Printf(\"Twice %v is %v\\n\", v, v*2) case string: fmt.Printf(\"%q is %v bytes long\\n\", v, len(v)) default: fmt.Printf(\"I don't know about type %T!\\n\", v) }}func main() { do(21) do(\"hello\") do(true)} 编译运行 123Twice 21 is 42\"hello\" is 5 bytes longI don't know about type bool! 可以看到v在匹配到类型的条件下值为相应类型的值，在未匹配的条件下v与i的接口类型和值相同 练习通过让IPAddr类型实现fmt.Stringer来打印点号分隔的地址 例如：IPAddr{1,2,3,4}应当打印为“1.2.3.4” Stringer接口 fmt包中定义的Stringer接口是最普遍的接口之一 123type Stringer interface { String() string} Stringer是一个可以用字符串描述自己的类型。fmt包中都通过此接口来打印值 练习1：exercise-stringer.go 1234567891011121314151617181920package mainimport \"fmt\"type IPAddr [4]byte//TODO: 给 IPAddr 添加一个 \"String() string\" 方法func (ipaddr IPAddr) String() string { return fmt.Sprintf(\"%v.%v.%v.%v\",ipaddr[0],ipaddr[1],ipaddr[2],ipaddr[3])}func main() { hosts := map[string]IPAddr{ \"loopback\": {127, 0, 0, 1}, \"googleDNS\": {8, 8, 8, 8}, } for name, ip := range hosts { fmt.Printf(\"%v: %v\\n\", name, ip) }} 编译运行 12loopback: 127.0.0.1googleDNS: 8.8.8.8 错误概述在程序运行中如果发生了错误，我们需要事先约定返回一个错误代码以供我们分析调试，这时就需要错误处理机制，不然我们只能一级级上报直到一个能够处理这个错误的函数 常见语言通常都内置了一套错误处理机制，Go语言也不例外 定义Go语言使用error值来表示错误状态，它是一个内建的接口 123type error interface { Error() string} 通常情况下函数会返回一个error值，调用它的代码应当判断这个错误是否等于nil来进行错误处理 error为nil时表示成功，反之为失败 示例10：errors.go 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\" \"time\")type MyError struct { When time.Time What string}func (e *MyError) Error() string { return fmt.Sprintf(\"at %v, %s\", e.When, e.What)}func run() error { return &amp;MyError{ time.Now(), \"it didn't work\", }}func main() { if err := run(); err != nil { fmt.Println(err) }} 编译运行 1at 2009-11-10 23:00:00 +0000 UTC m=+0.000000001, it didn't work 练习 从之前的练习中复制Sqrt函数，修改他使其返回error值。 Sqrt函数接受到一个负数时，应当返回一个非nil的错误值，同样复数也也不被支持 创建一个新的类型 1type ErrNegativeSqrt float64 并为其实现 1func (e ErrNegativeSqrt) Error() string {} 方法使其拥有error值，通过ErrNegativeSqrt(-2).Error调用该方法应返回“cannot Sqrt negative number: -2”。 注意 在Error方法内调用fmt.Sprint(e)会让程序陷入死循环。 我们可以通过先转换e来避免这个问题：fmt.Sprint(float64(e)) 修改Sqrt函数，使其接受一个负数时，返回ErrNegativeSqrt值 练习2：exercise-errors.go 123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\")type ErrNegativeSqrt float64func (e ErrNegativeSqrt) Error() string { if e &lt; 0 { return fmt.Sprint(\"cannot Sqrt negative number: \", float64(e)) } else { return \"\" }}func Sqrt(x float64) (float64, error) { z := float64(1) err := ErrNegativeSqrt(x) if x &lt; 0 { return 0, err } else { for i := 0; i &lt; 10; i++ { z -= (z*z - x) / (2 * z) } return z, err }}func main() { fmt.Println(Sqrt(2)) fmt.Println(Sqrt(-2))} 编译运行 121.414213562373095 0 cannot Sqrt negative number: -2 实现一个Reader类型，它产生一个ASCII字符‘A’的无限流 Reader接口 io包指定了io.Reader接口，它表示从数据流的末尾进行读取 io.Reader接口有一个Read方法 1func (T) Read(b []byte) (n int, err error) Read用数据填充给定的字节切片并返回填充的字节数和错误值，在遇到数据流结尾时，他会返回一个io.EOF错误 下面的示例代码创建了一个strings.Reader并以每次8字节的速度读取它的输出 123456789101112131415161718192021package mainimport ( \"fmt\" \"io\" \"strings\")func main() { r := strings.NewReader(\"Hello, Reader!\") b := make([]byte, 8) for { n, err := r.Read(b) fmt.Printf(\"n = %v err = %v b = %v\\n\", n, err, b) fmt.Printf(\"b[:n] = %q\\n\", b[:n]) if err == io.EOF { break } }} Go的标准库中包含了许多该接口的实现，包括文件、网络连接、压缩和加密等 练习3：exercise-reader.go 12345678910111213141516171819package mainimport \"golang.org/x/tour/reader\"type MyReader struct{}// TODO: 给 MyReader 添加一个 Read([]byte) (int, error) 方法func (r MyReader) Read(b []byte) (n int, err error) { for i:= range b { b[i] = 65 n = len(b) } return}func main() { reader.Validate(MyReader{})} 编写一个实现了io.Reader并从另一个io.Reader中读取数据的rot13Reader,通过应用rot13代换密码对数据流进行修改。 练习4：exercise-rot-reader.go 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"io\" \"os\" \"strings\")type rot13Reader struct { r io.Reader}func (r rot13Reader) Read(b []byte) (int, error) { n, err := r.r.Read(b) for i, v := range b { switch true { case v &gt;= 65 &amp;&amp; v &lt; 78: b[i] = v + 13 case v &gt;= 77 &amp;&amp; v &lt; 91: b[i] = v - 13 case v &gt;= 97 &amp;&amp; v &lt; 110: b[i] = v + 13 case v &gt;= 109 &amp;&amp; v &lt; 123: b[i] = v - 13 default: b[i] = v } } return n, err}func main() { s := strings.NewReader(\"Lbh penpxrq gur pbqr!\") r := rot13Reader{s} io.Copy(os.Stdout, &amp;r)} 编译运行 1You cracked the code! 定义一个Image类型，实现必要的方法并调用pic.ShowImage，使其返回一个image.Image的实现而非切片。 Bounds应当返回一个image.Rectangle，例如image.Rect(0,0,w,h) ColorModel应当返回color.RGBAModel At应当返回一个颜色。之前的图片生成器的值v对应于此次的color.RGBA{v,v,255,255} 在具体实现之前先看下Go内置的image包对Image接口的定义 1234567package imagetype Image interface { ColorModel() color.Model Bounds() Rectangle At(x,y int) color.Color} 注意 Bounds方法的返回值Rectangle实际上是一个image.Rectangle,他在image包中声明 在Go的文档中可以查到详细的信息 练习5：exercise-images.go 1234567891011121314151617181920212223242526package mainimport ( \"golang.org/x/tour/pic\" \"image\" \"image/color\")type Image struct{}func (i Image) Bounds() image.Rectangle { return image.Rect(0,0,200,200)}func (i Image) ColorModel() color.Model { return color.RGBAModel}func (i Image) At(x, y int) color.Color { return color.RGBA{uint8(x), uint8(y), uint8(255), uint8(255)}}func main() { m := Image{} pic.ShowImage(m)} 编译运行","link":"/2020/03/23/Go%E8%AF%AD%E8%A8%80%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E7%A1%80/"},{"title":"Go语言并发编程基础","text":"多线程（1）Go线程基本用法使用go关键字便可以创建一个新的Go线程（goroutine），goruntine是由Go运行时进行管理的轻量级线程，执行 1go f( x , y , z ) 会启动一个新的Go线程并执行 1f( x , y , z ) 其中f,x,y和z的求值发生在当前的线程中，而f的执行发生在新的线程中 Go线程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步 示例1：goroutine.go 123456789101112131415161718package mainimport ( \"fmt\" \"time\")func say(s string) { for i := 0; i &lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) }}func main() { go say(\"world\") say(\"hello\")} 编译运行 12345678910worldhellohelloworldworldhellohelloworldworldhello 可以看到两个线程是并行的 信道信道的基本用法既然有了多线程，那么程序要如何在多个线程之间通信，我们需要一种在多个线程之间交换数据的手段，这便是信道 信道是带有类型的管道，我们可以使用&lt;-操作符来使用管道发送或接收值 12ch &lt;- v //将v发送至信道chv := &lt;-ch //从ch接收值并赋值给v 与映射和切片一样，信道在使用前必须先创建 1ch := make(chan int) //声明一个存储int类型的信道ch并初始化 在默认情况下，发送和接收操作在另一端准备好之前都会阻塞，这样可以保证在没有显式锁或条件变量（condition variables）的情况下保持同步 示例2：channels.go 12345678910111213141516171819202122package mainimport \"fmt\"func sum(s []int, c chan int) { sum := 0 for _, v := range s{ sum += v } c &lt;-sum //将sum送入c}func main() { s := []int{7,2,8,-9,4,0} c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := &lt;-c, &lt;-c fmt.Println( x, y, x+y )} 编译运行 1-5 17 12 信道可以是带缓冲的，同样使用make()我们将缓冲长度作为第二个参数来初始化一个带缓冲信道 1ch := make(chan int, 100) 上面说过在默认情况下多个线程是同步的，而使用带缓冲的信道则可以实现线程之间的异步： 仅当信道的缓冲区被填满后，再向其发送数据才会阻塞 当信道缓冲区为空时，接收方会阻塞 示例3：buffered-channels.go 1234567891011package mainimport \"fmt\"func main() { ch := make(chan int,2) ch &lt;- 1 ch &lt;- 2 fmt.Println(&lt;-ch) fmt.Println(&lt;-ch)} 编译运行 1212 示例中初始化了一个缓冲区长度为2的信道，我们向这个信道同时发送了两个数据而没有阻塞 对示例进行一下修改 12345678func main() { ch := make(chan int,2) ch &lt;- 1 ch &lt;- 2 ch &lt;- 3 fmt.Println(&lt;-ch) fmt.Println(&lt;-ch)} 编译运行 1fatal error: all goroutines are asleep - deadlock! 可以看到在缓冲区被填满后向信道发送数据的行为会报错。同样的，从一个空信道中读取数据也会报错 123456func main() { ch := make(chan int,2) ch &lt;- 1 fmt.Println(&lt;-ch) fmt.Println(&lt;-ch)} 编译运行 121fatal error: all goroutines are asleep - deadlock! 信道的遍历和关闭信道可以在发送者没有需要发送的值后通过close被关闭。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭，如果没有值可接收且信道已被关闭，则在执行完 1v , ok := &lt;-ch 之后，ok的值会被设置为false 遍历一个信道中缓存的所有值可以使用for循环，形式与一般的使用range的循环并没有区别 1for i := range c 循环会不断地从信道中接收值，直到这个信道被关闭 注意 只有发送者才能关闭通道，而接收者不能 向一个关闭的信道发送数据会引发程序恐慌（panic） 信道与文件不同，通常情况下无需关闭它们，只有在必须告诉接收者不再有需要发送的值时3才有必要关闭，例如终止一个range循环 示例4：range-and-close.go 1234567891011121314151617181920package mainimport \"fmt\"func fibonacci(n int,c chan int) { x, y := 0, 1 for i := 0; i &lt; n; i++ { c &lt;- x x, y = y , x + y } close(c)}func main() { c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c { fmt.Println(i) }} 编译运行 123456789100112358132134 多线程（2）select的用法使用select语句可以使线程等待多个通信操作，select会阻塞直到其中的某个分支可以继续执行为止，这时便会执行该分支 12345678910111213select { case case1: ... case case2: ... ... case casen: ... default: ...} 当多个分支都准备好时会随机选择一个执行 示例5：select.go 12345678910111213141516171819202122232425262728package mainimport \"fmt\"func fibonacci(c, quit chan int) { x, y := 0, 1 for { select { case c &lt;- x: x, y = y, x+y case &lt;-quit: fmt.Println(\"quit\") return } }}func main() { c := make(chan int) quit := make(chan int) go func() { for i := 0; i &lt; 10; i++ { fmt.Println(&lt;-c) } quit &lt;- 0 }() fibonacci(c, quit)} 编译运行 12345678910110112358132134quit 当select中的其他分支均未准备好时，会执行default分支，使用这种方法可以在尝试发送或接收时不发生阻塞 123456select { case i := &lt;-c: // 使用i default: // 从c中接收会阻塞时执行} 下面的示例就展示了这种用法 示例6：default-selection.go 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"time\")func main() { tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) for { select { case &lt;-tick: fmt.Println(\"tick.\") case &lt;-boom: fmt.Println(\"BOOM!\") return default: fmt.Println(\" .\") time.Sleep(50 * time.Millisecond) } }} 编译运行 123456789101112131415 . .tick. . .tick. . .tick. . .tick. . .BOOM! 练习练习1：等价二叉查找树不同二叉树的叶子节点上可以保存相同的值序列，例如下面两隔二叉树都保存了序列‘1，1，2，3，5，8，13’在大多数语言中检查两个二叉树是否保存了相同序列的函数都相当复杂。 我们将使用Go的并发和信道来编写一个简单的解法 本例使用了tree包，他定义了类型 12345type Tree struct { Left *Tree Value int Right *Tree} 你需要 实现Walk函数 测试Walk函数 函数tree.New(k)用于构造一个随机结构的已排序二叉查找树，它保存了值‘k,2k,3k,…,10k’ 创建一个新的信道ch并且对其进行步进 1go Walk(tree.New(1), ch) 然后从信道中读取并打印10个值，它们应当是1，2，3……10 用Walk实现Same函数来检测t1和t2是否存储了相同的值 测试Same函数 Same(tree.New(1),tree.New(1))应当返回true，反之Same(tree.New(1),tree.New(2))应当返回false Tree的具体文档可以在这里找到 练习1：exercise-equivalent-binary-trees.go 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( \"golang.org/x/tour/tree\" \"fmt\")// Walk 步进 tree t 将所有的值从 tree 发送到 channel ch。func Walk(t *tree.Tree, ch chan int) { if t == nil { return } else { Walk(t.Left, ch) ch &lt;- t.Value Walk(t.Right, ch) } return}// Same 检测树 t1 和 t2 是否含有相同的值。func Same(t1, t2 *tree.Tree) bool { ch1, ch2 := make(chan int), make(chan int) go Walk(t1, ch1) go Walk(t2, ch2) for { if &lt;-ch1 == &lt;-ch2 { return true } return false }}func main() { t := tree.New(1) ch := make(chan int) go Walk(t, ch) for i := 0; i &lt; 10; i++ { fmt.Println(&lt;-ch) } fmt.Println(Same(tree.New(1), tree.New(1))) fmt.Println(Same(tree.New(1), tree.New(2)))} 编译运行 12345678910111212345678910truefalse 练习2：Web爬虫在这个练习中，我们将会使用Go的并发特性来并行化一个Web爬虫。 修改Crawl函数来并行地抓取URL，并且保证不重复 提示： 你可以用一个map来缓存已经获取的URL，但是要注意map本身并不是并发安全的 什么是并发安全 在多个线程访问同一个对象时，如果不需要考虑这些线程的运行时环境下的调度和交替执行，也不需要额外同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的 Go的标准库中提供了互斥锁来保证变量的并发安全，它提供给我们一个sync.Mutex互斥锁类型及其两个方法：Lock和Unlock 通过在代码前调用Lock方法，在代码后调用Unlock方法便可以保证一段代码的互斥执行，这样同一时刻就只有一个go线程可以访问对象 练习2：exercise-web-crawler.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package mainimport ( \"fmt\" \"sync\")type Fetcher interface { // Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。 Fetch(url string) (body string, urls []string, err error)}type Cache struct { cache map[string]int mux sync.Mutex wg sync.WaitGroup}var c = Cache{cache: make(map[string]int)}// Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。func Crawl(url string, depth int, fetcher Fetcher) { // TODO: 并行的抓取 URL。 // TODO: 不重复抓取页面。 // 下面并没有实现上面两种情况： defer c.wg.Done() if depth &lt;= 0 { return } c.mux.Lock() c.cache[url]++ c.mux.Unlock() body, urls, err := fetcher.Fetch(url) if err != nil { fmt.Println(err) return } fmt.Printf(\"found: %s %q\\n\", url, body) for _, u := range urls { c.mux.Lock() if _, ok := c.cache[u]; !ok { c.wg.Add(1) go Crawl(u, depth-1, fetcher) } c.mux.Unlock() } return}func main() { c.wg.Add(1) Crawl(\"https://golang.org/\", 4, fetcher) c.wg.Wait()}// fakeFetcher 是返回若干结果的 Fetcher。type fakeFetcher map[string]*fakeResulttype fakeResult struct { body string urls []string}func (f fakeFetcher) Fetch(url string) (string, []string, error) { if res, ok := f[url]; ok { return res.body, res.urls, nil } return \"\", nil, fmt.Errorf(\"not found: %s\", url)}// fetcher 是填充后的 fakeFetcher。var fetcher = fakeFetcher{ \"https://golang.org/\": &amp;fakeResult{ \"The Go Programming Language\", []string{ \"https://golang.org/pkg/\", \"https://golang.org/cmd/\", }, }, \"https://golang.org/pkg/\": &amp;fakeResult{ \"Packages\", []string{ \"https://golang.org/\", \"https://golang.org/cmd/\", \"https://golang.org/pkg/fmt/\", \"https://golang.org/pkg/os/\", }, }, \"https://golang.org/pkg/fmt/\": &amp;fakeResult{ \"Package fmt\", []string{ \"https://golang.org/\", \"https://golang.org/pkg/\", }, }, \"https://golang.org/pkg/os/\": &amp;fakeResult{ \"Package os\", []string{ \"https://golang.org/\", \"https://golang.org/pkg/\", }, },} 编译运行 12345found: https://golang.org/ \"The Go Programming Language\"not found: https://golang.org/cmd/found: https://golang.org/pkg/ \"Packages\"found: https://golang.org/pkg/os/ \"Package os\"found: https://golang.org/pkg/fmt/ \"Package fmt\"","link":"/2020/03/29/Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"title":"开源论坛Flarum的安装与使用","text":"Flarum 简介提到开源论坛程序，我们最先都会想到discuz和phpwind这种巨头，但是长时间的发展也令他们的程序越发发庞大和臃肿，对于开发者来说如果只想要单纯的论坛功能无疑是拿高射炮打蚊子，不仅大材小用，同时在维护上也更加耗费精力。 在这种情况下选择一个轻量的论坛程序不失为一个明智的选择，Flarum就是这样一个优雅的轻量论坛软件，它拥有一个现代的、简洁优雅的界面，同时可以通过插件来实现各种强大的功能。 目前Flarum还处于Beta版，当前版本已经可以支持绝大多数常用的论坛功能的需求，开发者仍然在不断的迭代，相信未来会有一个大好前景。 就像Flarum的开发者说的那样: Flarum is the combined successor of esoTalk and FluxBB. It is designed to be: Fast and simple. No clutter, no bloat, no complex dependencies. Flarum is built with PHP so it’s quick and easy to deploy. The interface is powered by Mithril, a performant JavaScript framework with a tiny footprint. Beautiful and responsive. This is forum software for humans. Flarum is carefully designed to be consistent and intuitive across platforms, out-of-the-box. Powerful and extensible. Customize, extend, and integrate Flarum to suit your community. Flarum’s architecture is amazingly flexible, with a powerful Extension API. Free and open. Flarum is released under the MIT license. 官方网站 官方文档 开发者社区 安装系统要求要安装Flarum，首先需要服务器配置好如下环境： Apache（开启了mod_rewrite）或者Nginx PHP 7.1以上并且安装以下扩展：curl,dom,gd,json,mbstring,openssl,pdo_mysql,tokenizer,zip MySQL 5.6以上或者MariaDB 10.0.5以上 SSH(命令行)权限用于运行Composer 目前Flarum的版本是beta12，官方已经宣布将在beta13时弃用PHP 7.1，因此为避免版本升级的各种麻烦，最好使用7.2以上版本 配置环境以下配置方法基于我本人的腾讯云服务器，操作系统为CentOS 8，具体操作根据服务商和系统的不同可能会有所差异 我是用的是LNMP环境，即使用Linux、Nginx、MySQL、PHP作为网站的服务器架构 Apache的使用方法还请自行探索 安装Nginx以下命令均在root用户下执行，如果使用非root用户，则需要在开头加上sudo 执行命令，安装nginx 1yum install nginx 注意安装的版本，系统默认源的nginx版本可能比较低，如果希望安装最新的stable版本的nginx则需要额外几个步骤： 安装yum-utils1yum install yum-utils 更新nginx的yum源，创建并编辑文件/etc/yum.repos.d/nginx.repo123456789101112131415[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true[nginx-mainline]name=nginx mainline repobaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck=1enabled=0gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true 默认情况下会安装stable版本，如果想要安装mainline版本则运行以下命令1yum-config-manager --enable nginx-mainline 最后重新运行yum install命令1yum install nginx 安装完成后运行nginx 1systemctl start nginx 并且设置为开机启动 1systemctl enable nginx 从浏览器输入服务器地址访问服务器，如果展示如下页面则表示nginx已成功运行 安装数据库鉴于MySQL数据库版本众多，建议使用官方的配置生成页面按照自己的需求生成相应的配置文件，例如我的选择是CentOS 8和10.4[stable] 创建文件/etc/yum.repos.d/mariadb.repo并写入生成的配置12345678# MariaDB 10.4 CentOS repository list - created 2020-04-22 17:13 UTC# http://downloads.mariadb.org/mariadb/repositories/[mariadb]name = MariaDBbaseurl = http://yum.mariadb.org/10.4/centos8-amd64module_hotfixes=1gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDBgpgcheck=1 运行yum install1yum install MariaDB-server MariaDB-client 启动mariadb1systemctl start mariadb 设置为开机启动1systemctl enable mariadb 执行命令1mysql 如果出现如下界面则代表成功安装 使用 1\\q 退出mysql 安装PHPCentOS 8默认源的PHP版本为7.2，已经满足了Flarum的要求 直接执行命令1yum install php php-cli php-common php-mysqlnd php-fpm 安装完成后检查PHP的版本1php -v Flarum需求的一些php扩展还没有安装，在安装之前可以先检查已经安装了哪些扩展 执行命令 1php -m 根据需要查漏补缺安装php扩展 1yum install php-dom php-gd php-zip php-mbstring 启动PHP 1systemctl start php-fpm 设为开机启动 1systemctl enable php-fpm 至此LNMP架构全部安装完成，接下来还要配置一些参数，并进行验证，使服务器能够像我们期望的那样运行起来 配置参数首先要对nginx进行配置 nginx默认配置下是不能解析php文件的，需要nginx转发给fastcgi来解析php文件 首先找到nginx的配置文件，默认情况下位于/etc/nginx/conf.d，如果该文件夹下为空则直接创建一个新文件，并命名为default.conf 编辑default.conf123456789101112131415161718192021222324252627server { listen 80; root /usr/share/nginx/html; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; # location / { index index.php index.html index.htm; } #error_page 404 /404.html; #redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } #pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ .php$ { root /usr/share/nginx/html; fastcgi_pass unix:/run/php-fpm/www.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; }} 保存文件后返回，接下来需要验证nginx现在是否已经可以正确处理php文件 执行以下命令，创建一个测试文件1echo \"&lt;?php phpinfo(); ?&gt;\" &gt;&gt; /usr/share/nginx/html/index.php 重启nginx1systemctl restart nginx 在浏览器中访问服务器地址，如果显示如下结果，则表示配置成功 至此，服务器环境便配置完成了，接下来便可以进行Flarum的安装。 安装FlarumFlarum使用Composer进行安装，Composer是一个PHP软件包管理器 因此需要首先安装Composer，Composer的官方网站给出了详细的安装方式 依次运行命令 1234php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\"php -r \"if (hash_file('sha384', 'composer-setup.php') === 'e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;\"php composer-setup.phpphp -r \"unlink('composer-setup.php');\" 这时composer便已经安装完成，不过这时composer只能在当前路径运行，为了方便起见，我们需要让它可以以全局方式运行 执行以下命令 1mv composer.phar /usr/local/bin/composer 这样Composer便可以全局运行了 转到网站根目录 1cd /a/example/path/to/flarum 运行composer 1composer create-project flarum/flarum . --stability=beta 由于Composer源位于国外，连接速度感人，需要改为国内的镜像源，比如阿里或者腾讯的镜像 这里我使用的是腾讯的镜像,具体使用方法见：Composer镜像使用帮助 修改default.conf，使nginx服务器的根目录指向网站的根目录，找到如下内容 1root /usr/share/nginx/html; 修改为网站的根目录 1root /path/to/flarum/public; Flarum的文件结构如下 1234567891011121314. （站点根目录）├── public（公共目录）│ └── assets （资源目录，存放头像、上传的文件等）├── storage│ └── logs （日志）├── vendor （核心、插件目录）├── .nginx.conf （自带 Nginx 配置）├── .htaccess （自带 Apache 配置）├── composer.json（插件列表）├── extend.php（自定义扩展文件）├── flarum├── LICENSE├── README.md└── site.php 除了public之外浏览器不应有其他目录的访问权限，所以注意路径应指向public文件夹 接下来需要将自带的nginx配置文件加入nginx配置中 向default.conf中的server代码块中加入如下代码1include /path/to/flarum/.nginx.conf 并重启nginx 此时访问服务器地址就能看到如下Flarum的安装界面了 接下来只要根据安装界面的提示进行就可以成功安装了，例如上面展示的，现在网站目录的权限不足，Flarum的安装程序不能写入文件，这时就需要使用chomd命令来改变目录的权限 1chmod -R 775 /path/to/flarum 注意：永远不要使用777的权限设置，这意味着所有人均能访问读取和修改目录下的文件 权限设置完毕后，就需要设置管理员、数据库等参数了 分别需要设置： Forum Title：论坛的标题，没啥好说的 MySQL Host：定位数据库的主机，如果数据库位于本地为localhost，位于网络中则为目标机器的ip地址 MySQL Database：定位具体的数据库，注意Flarum的安装程序不会自动创建相应的datbase，需要先行建立一个相应的database MySQL Username：指定访问数据库的用户名，注意MySQL在没有额外设置的情况下是允许匿名登录的，如果要部署到生产环境需要对MySQL进行权限设置，禁止匿名用户访问数据库 MySQL Password：登录数据库时所需的密码 Table Prefix：数据库prefix参数，不清楚具体作用的话留空即可 Admin Username：设定系统管理员的用户名，同样没啥好说的 Admin Email：设定系统管理员的邮箱地址 Admin Password：设定管理员用户密码 下面贴上我自己在虚拟机上填写的内容作为参考 确认上述一切都没有问题后，点击安装，整个安装配置过程便完成了，稍作等待便可以看到论坛的页面了 安装扩展Flarum本身作为一个轻量的论坛，其功能还是很少的，仅能满足基本的需求。不过作为一个开源项目，自然也少不了社区的支持，现在已经有众多的扩展插件可以选择。 进入论坛的管理后台页面就可以看到扩展面板，里面展示了当前已经安装和开启的插件 不过当前版本还不能直接从页面中添加扩展，仍然需要使用命令行工具安装，再从管理面板中启用。 常用的扩展可以从Flarum官方论坛中的extension标签的帖子中寻找或者使用Bazaar以及FoF来完成 这部分内容就请各位自行探索吧！","link":"/2020/04/23/%E5%BC%80%E6%BA%90%E8%AE%BA%E5%9D%9BFlarum%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"title":"Gin学习笔记|0","text":"Gin是什么概述Gin是一个由Go语言编写的开源框架，自称是目前速度最快，性能最好的HTTP web框架，引用官方介绍： Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API with much better performance – up to 40 times faster. If you need smashing performance, get yourself some Gin. Gin已经在Github上开源，同时也开源了众多的中间件可供使用： 项目地址 特性引用自Gin的官方文档 快速（Fast）基于Radix树的路由，内存占用极少。没有反射，可预测的API性能 中间件支持传入的HTTP请求可以由一系列的中间件来处理，例如：Logger,Authorization,GZIP，最终操作数据库 异常处理服务会保持始终可用。Gin可以捕获panic，并尝试进行恢复。而且有极为便利的机制处理HTTP请求过程中发生的错误。 JSON验证Gin可以解析并验证请求的JSON 路由组更好地组织路由，例如是否需要授权、不同的API版本，可以无限制地嵌套且不会影响性能 内置渲染Gin为JSON、XML和HTML的渲染提供了易用的内置API 可扩展性可以很方便地编写新的中间件 Gin的安装Go的安装在Linux系统下可以直接使用包管理进行安装，不过需要注意Go的版本，一部分Linux发行版并没有包含最新版本的Go，这种情况下可以选择自行下载二进制文件或直接从源码安装，在Go的官网有具体方法，这里便不再赘述。 Debian/Ubuntu： 1$ sudo apt install golang RHEL/CentOS： 1$ sudo yum install golang 使用 1$ go version 来检查是否安装成功，输出应该是如下形式： 1go version go1.13.8 linux/amd64","link":"/2020/05/23/Gin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-0/"}],"tags":[{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Flarum","slug":"Flarum","link":"/tags/Flarum/"},{"name":"Web","slug":"Web","link":"/tags/Web/"}],"categories":[{"name":"Golang","slug":"Golang","link":"/categories/Golang/"},{"name":"基础","slug":"Golang/基础","link":"/categories/Golang/%E5%9F%BA%E7%A1%80/"},{"name":"进阶","slug":"Golang/进阶","link":"/categories/Golang/%E8%BF%9B%E9%98%B6/"},{"name":"Web应用","slug":"Web应用","link":"/categories/Web%E5%BA%94%E7%94%A8/"},{"name":"Flarum","slug":"Web应用/Flarum","link":"/categories/Web%E5%BA%94%E7%94%A8/Flarum/"},{"name":"Web","slug":"Golang/Web","link":"/categories/Golang/Web/"}]}